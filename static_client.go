package api2

import (
	"bytes"
	"fmt"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"runtime"
	"strings"
	"text/template"
)

func getMethod(handler interface{}) (name, request, response string, err error) {
	// Get request and response names.
	handlerFunc := handler
	type Funcer interface {
		Func() interface{}
	}
	funcer, ok := handler.(Funcer)
	if ok {
		handlerFunc = funcer.Func()
	}

	handlerType := reflect.TypeOf(handlerFunc)
	request = handlerType.In(1).Elem().Name()
	response = handlerType.Out(0).Elem().Name()

	// Try to extract method name from a result of api2.Method().
	type FuncInfoer interface {
		FuncInfo() (pkgFull, pkgName, structName, method string)
	}
	fi, ok := handler.(FuncInfoer)
	if ok {
		_, _, _, name = fi.FuncInfo()
		return
	}

	// Fallback: try to get method name from request and response names.

	conventions := []struct {
		request, response string
	}{
		{request: "Request", response: "Response"},
		{request: "Args", response: "Reply"},
		{request: "Req", response: "Resp"},
		{request: "Req", response: "Res"},
	}

	for _, conv := range conventions {
		nameFromReq := strings.TrimSuffix(request, conv.request)
		nameFromRes := strings.TrimSuffix(response, conv.response)
		if nameFromReq == nameFromRes {
			name = nameFromReq
			return
		}
	}

	err = fmt.Errorf("can not deduce method name. Use api2.Method or name your request and response types like FooRequest and FooResponse")
	return
}

func getFileByFunction(f interface{}) string {
	rf := runtime.FuncForPC(reflect.ValueOf(f).Pointer())
	fileName, _ := rf.FileLine(rf.Entry())
	return fileName
}

func runTemplate(routes []Route, pkg, api2pkg, serviceInterface string) (code string, err error) {
	type Method struct {
		Name     string
		Request  string
		Response string
	}

	type Vars struct {
		Pkg              string
		Api2Pkg          string
		ServiceInterface string
		Methods          []Method
	}

	methods := make([]Method, 0, len(routes))
	for i, r := range routes {
		name, request, response, err := getMethod(r.Handler)
		if err != nil {
			return "", fmt.Errorf("failed to analyze method %d in package %s: %v", i, pkg, err)
		}
		methods = append(methods, Method{
			Name:     name,
			Request:  request,
			Response: response,
		})
	}

	vars := Vars{
		Pkg:              pkg,
		Api2Pkg:          api2pkg,
		ServiceInterface: serviceInterface,
		Methods:          methods,
	}

	var codeBuf bytes.Buffer
	if err := clientTemplate.Execute(&codeBuf, vars); err != nil {
		return "", fmt.Errorf("template executation failed for package %s: %v", pkg, err)
	}

	return codeBuf.String(), nil
}

var clientTemplate = template.Must(template.New("static_client").Parse(clientTemplateStr))

const clientTemplateStr = `package {{ .Pkg }}

// Code generated by api2. DO NOT EDIT.

import (
	"context"
	"net/url"

	"{{ .Api2Pkg }}"
)

type Client struct {
	api2client *api2.Client
}
{{ if .ServiceInterface }}
var _ {{ .ServiceInterface }} = (*Client)(nil)
{{ end }}
func NewClient(baseURL string) (*Client, error) {
	if _, err := url.ParseRequestURI(baseURL); err != nil {
		return nil, err
	}
	routes := GetRoutes(nil)
	api2client := api2.NewClient(routes, baseURL)
	return &Client{
		api2client: api2client,
	}, nil
}
{{ range .Methods }}
func (c *Client) {{ .Name }}(ctx context.Context, req *{{ .Request }}) (res *{{ .Response }}, err error) {
	res = &{{ .Response }}{}
	err = c.api2client.Call(ctx, res, req)
	if err != nil {
		return nil, err
	}
	return
}
{{end}}`

// GenerateClientCode accepts global function GetRoutes of a package and
// returns the code of static client and path to the file where the code
// should be saved (client.go in the same directory where GetRoutes and
// types of requests, responses and service are defined.
func GenerateClientCode(getRoutes interface{}) (code, clientFile string, err error) {
	fileName := getFileByFunction(getRoutes)

	// Check that the file does not exist or was generated.
	dir := filepath.Dir(fileName)
	clientFile = filepath.Join(dir, "client.go")

	pkg, api2pkg, err := detectPkgs(dir)
	if err != nil {
		return "", "", fmt.Errorf("failed to determine pkg and api2pkg for dir %s: %v", dir, err)
	}

	genValue := reflect.ValueOf(getRoutes)
	serviceArg := reflect.New(genValue.Type().In(0)).Elem()
	routesValues := genValue.Call([]reflect.Value{serviceArg})
	routes := routesValues[0].Interface().([]Route)

	serviceInterface := genValue.Type().In(0).Name()
	if genValue.Type().In(0).Kind() != reflect.Interface {
		serviceInterface = ""
	}

	code, err = runTemplate(routes, pkg, api2pkg, serviceInterface)
	if err != nil {
		return "", "", err
	}

	return code, clientFile, nil
}

// GenerateClient generates file client.go with static client near the file
// in which passed GetRoutes function is defined.
func GenerateClient(getRoutes interface{}) {
	fileName := getFileByFunction(getRoutes)
	log.Printf("api2 generates static client for %s ...", fileName)
	if err := generateClient(getRoutes); err != nil {
		log.Fatalf("api2 failed to generate static client for %s: %v", fileName, err)
	}
}

var codeGeneratedRE = regexp.MustCompile(`.*Code generated .* DO NOT EDIT\..*`)

func generateClient(getRoutes interface{}) error {
	code, clientFile, err := GenerateClientCode(getRoutes)
	if err != nil {
		return err
	}

	// Check that the file does not exist or was generated.
	oldContent, err := ioutil.ReadFile(clientFile)
	if err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("unknown error when reading from %s: %v", clientFile, err)
	} else if err == nil && !codeGeneratedRE.Match(oldContent) {
		return fmt.Errorf("file %s exists and was not generated; please remove it to proceed", clientFile)
	}

	if err := ioutil.WriteFile(clientFile, []byte(code), 0644); err != nil {
		return fmt.Errorf("failed to write file %s: %v", clientFile, err)
	}

	return nil
}

func detectPkgs(dir string) (pkg, api2pkg string, err error) {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, nil, parser.ImportsOnly)
	if err != nil {
		return "", "", err
	}
	var pkgNames []string
	for pkgName := range pkgs {
		pkgNames = append(pkgNames, pkgName)
	}
	if len(pkgNames) != 1 {
		return "", "", fmt.Errorf("found %d packages (%v) in dir %s, want %d", len(pkgNames), pkgNames, dir, 1)
	}
	pkg = pkgNames[0]

	for _, gofile := range pkgs[pkg].Files {
		for _, importSpec := range gofile.Imports {
			importPath := importSpec.Path.Value
			importPath = strings.TrimPrefix(importPath, `"`)
			importPath = strings.TrimSuffix(importPath, `"`)
			if !strings.HasSuffix(importPath, "/api2") {
				continue
			}
			api2pkg = importPath
			return
		}
	}

	return "", "", fmt.Errorf("failed to find import of api2 in dir %s", dir)
}
